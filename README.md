<img src="/img/logo.png">
<h1>MVC BOT</h1>
<hr>
Данная библиотека облегчает создание ботов для VK через CallBack API
в несколько сотен раз<br>
Добавив ее в проект, можно создать Hello World бота за несколько секунд.<br>
Что же она может?
<br>
<h2>Создание команд</h2>
<code>Handler::Register('hello-world', function () {<br>
    return 'Hello world';
<br>});
</code><br>
Как вы можете видеть в коде выше -- это делается в пару строк.<br>
Вы вызываете метод Register из класса Handler в файле /Config/Command.php<br>
<br>
Первый аргумент -- это название функции. Может быть или string, или array. <br> 
Второй -- это сама функция, которая вызовется в случае набора команды. Это может быть или анонимная функция, или строка
<br>
Если это строка, то там указывается контроллер, и функция через @.<br>
Т.е, строка:<br>
Hello@World<br>
Создаст экземпляр класса ControllerHello из файла /Controller/ControllerHello.php, и вызовет метод ActionWorld<br>
<br>
Так-же, можно передавать аргументы:<br>
<code>Handler::Register('name', function ($name, $age) {<br>
    return "Hello, {$name} ({$age} years old)";
<br>});
</code><br>
При отправке боту такого сообщения:<br>
name Антон 17<br>
Человеку в ответ бот отошлет "Hello, Антон (17 years old)"
<br>
<h2>Регистрация Event'ов</h2>
Допустим, нам надо захватить приходящий от VK тип message_new, как это сделать?<br>
Пишем такие строчки в файле /Config/Event.php:<br>
<code>Event::Register('message_new', function () {<br>
          Handler::Run();<br>
          Logger::Info("Пришел тип message_new");<br>
      });
</code><br>
Теперь анонимная функция (или строка) которую вы указали во втором аргументе, будет вызываться каждый раз, когда будет приходить этот тип
<h2>Дополнительно</h2>
<hr>
Конечно-же, это не все возможности библиотеки.<br>
<h3>Обращения к боту</h3><br>Бота можно заставить игнорировать сообщения, в которых не присутствует обращение к нему. Это делается так:<br>
<code>
Handler::UseAppeal(true);<br>
Handler::AddAppeal('Bot');
</code> <small>Этот код будет работать только в файле /Config/Command.php, или /Config/Event.php</small><br>
Теперь, бот не будет отзываться на такие сообщения:<br>
name Антон 17<br>
Но, будет отзываться на:<br>
Bot name Антон 17<br>
Так-же, в первый аргумент метода AddApeal можно передать не только string, но и array.<br>
<code>Handler::AddApeal(['Бот', 'Ботец']);</code><br>
Теперь, бот будет отзываться и на Бот, и на Ботец.

<h3>Игнор-режим</h3>
Еще, бота можно заставить игнорировать сообщения, которые не начинаются с определенного символа.<br>
<code>Handler::IgnoreMode(true, $char);</code><br>
$char -- символ, с которого должно начинаться сообщение. Т.е, такой код:
<code>Handler::IgnoreMode(true, '/');</code><br>
Сделает так, что вот такие обращения не будут работать:<br>
name Антон 17<br>
А такие будут:<br>
/name Антон 17

<h3>Строгая проверка</h3><br>
Можно включить строгую проверку. Она будет сверять регистр функций, и обращений.<br>

Допустим, у нас есть обращение "Бот", и пользователь пишет:<br>
бот, name Антон 17<br>
При выключенной строгой проверке, это сообщение вызовет функцию name<br>
При включенной -- выведет ошибку о том, что такая функция не обнаружена.

Включить строгую проверку: <code>Handler::SetStrict(true);</code> <small>Включение строгой проверки нужно поместить в начало файла Config/Controller.php, иначе не будет работать.</small>
<h3>Ошибки</h3><br>
Согласитесь, неудобно писать каждый раз, при ошибке:<br>
<code>
BotMessage::Send('ОШИБКА: Неизвестный символ');<br>
return "";
</code><br>
Именно поэтому, я сделал такую фишку. Если в возвращаемом значении, первый символ это @, то это выведет как ошибку:<br>
<code>return "@Неизвестный символ";</code><br>Код выше, отправит сообщение пользователю такое: "ОШИБКА: Неизвестный символ"<br>
<small>Символ можно сменить с @, на любой другой, в файле /Config/config.ini</code>