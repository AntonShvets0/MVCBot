<img src="/img/logo.png">
<h1>MVC BOT</h1>
<hr>
Данная библиотека облегчает создание ботов для VK через CallBack API
в несколько сотен раз<br>
Добавив ее в проект, можно создать Hello World бота за несколько секунд.<br>
Что же она может?
<br>
<h2>Создание команд</h2>

```php
Handler::Register('hello-world', function () {
    return 'Hello world';
});
```
Как вы можете видеть в коде выше — это делается в пару строк.<br>
Вы вызываете метод Register из класса Handler в файле /Config/Command.php<br>
<br>
Первый аргумент — это название функции. Может быть или string, или array. <br> 
Второй — это сама функция, которая вызовется в случае набора команды. Это может быть или анонимная функция, или строка
<br>
Если это строка, то там указывается контроллер, и функция через @.<br>
Т.е, строка:<br>
Hello@World<br>
Создаст экземпляр класса ControllerHello из файла /Controller/ControllerHello.php, и вызовет метод ActionWorld<br>
<br>
Так-же, можно передавать аргументы:<br>
```php
Handler::Register('name', function ($name, $age) {
    return "Hello, {$name} ({$age} years old)";
});
```
<br>
При отправке боту такого сообщения:<br>
name Антон 17<br>
Человеку в ответ бот отошлет "Hello, Антон (17 years old)"
<br>
<h2>Регистрация Event'ов</h2>
Допустим, нам надо захватить приходящий от VK тип message_new, как это сделать?<br>
Пишем такие строчки в файле /Config/Event.php:<br>
```php
Event::Register('message_new', function () {
      Handler::Run();
      Logger::Info("Пришел тип message_new");
});
```
Теперь анонимная функция (или строка) которую вы указали во втором аргументе, будет вызываться каждый раз, когда будет приходить этот тип
<h2>Дополнительно</h2>
<hr>
Конечно-же, это не все возможности библиотеки.<br>
<h3>Обращения к боту</h3><br>Бота можно заставить игнорировать сообщения, в которых не присутствует обращение к нему. Это делается так:<br>

```php
Handler::UseAppeal(true);
Handler::AddAppeal('Bot');
```
<small>Этот код будет работать только в файле /Config/Command.php, или /Config/Event.php</small><br>
Теперь, бот не будет отзываться на такие сообщения:<br>
name Антон 17<br>
Но, будет отзываться на:<br>
Bot name Антон 17<br>
Так-же, в первый аргумент метода AddApeal можно передать не только string, но и array.<br>
```php
Handler::AddApeal(['Бот', 'Ботец']);
```
Теперь, бот будет отзываться и на Бот, и на Ботец.

<h3>Игнор-режим</h3>
Еще, бота можно заставить игнорировать сообщения, которые не начинаются с определенного символа.<br>

```php
Handler::IgnoreMode(true, $char);
```

$char — символ, с которого должно начинаться сообщение. Т.е, такой код:

```php
Handler::IgnoreMode(true, '/');
```

Сделает так, что вот такие обращения не будут работать:<br>
name Антон 17<br>
А такие будут:<br>
/name Антон 17

<h3>Строгая проверка</h3><br>
Можно включить строгую проверку. Она будет сверять регистр функций, и обращений.<br>

Допустим, у нас есть обращение "Бот", и пользователь пишет:<br>
бот, name Антон 17<br>
При выключенной строгой проверке, это сообщение вызовет функцию name<br>
При включенной — выведет ошибку о том, что такая функция не обнаружена.

Включить строгую проверку: 
```php
Handler::SetStrict(true);
```
<small>Включение строгой проверки нужно поместить в начало файла Config/Command.php, иначе не будет работать.</small>
<h3>Ошибки</h3><br>
Согласитесь, неудобно писать каждый раз, при ошибке:<br>

```php
BotMessage::Send('ОШИБКА: Неизвестный символ');
return "";
```

<br>
Именно поэтому, я сделал такую фишку. Если в возвращаемом значении, первый символ это @, то это выведет как ошибку:<br>

```php
return "@Неизвестный символ";
```


<br>Код выше, отправит сообщение пользователю такое: "ОШИБКА: Неизвестный символ"<br>
<small>Символ можно сменить с @, на любой другой, в файле /Config/config.ini</small>

<h2>Встроенные классы для работы с VK API</h2>
<hr>
В библиотеке встроены классы для работы с VK API. Список методов ниже:<br>

```php
BotMessage::Send($message, $id = 'callback', $attach = [], $keyBoard = []);
```

Отсылает сообщение пользователю. Если $id равняется callback, то это отправит тому пользователю, от которого пришел callback сайту.<br>
```php
BotRequest::On($method, $data = [])</code>
```
Отправляет запрос на api.vk.com, и возвращает массив.
<br>
```php
BotGet::From()
```
Возвращает from_id<br>
```php
BotGet::Peer()
```
Возвращает peer_id<br>
```php
BotGet::Message()
``` 
Возвращает сообщение пользователя<br>
<h2>Встроенный логгер</h2>
<hr>
В библиотеку встроен логгер. Методы логгера ниже:<br>

```php
Logger::Info($message)
```
Создает запись в логах, с типом Default<br>
```php
Logger::Error($message)
```
Создает запись в логах, с типом Error<br>
```php
Logger::Warning($message)
```
Создает запись в логах, с типом Warning
<h2>Клавиатура ботов</h2>
<hr>
Я немного изменил синтаксис клавиатуры ботов. Т.к оригинальный синтаксис от ВК меня пугает.<br>
Чтобы создать клавиатуру, в моей библиотеке следует создать простой массив:

```php

$keyBoard = [
    true, // Скрывать ли клавиатуру после нажатия. false/true

    [ // первая строка
        "Первая кнопка" => [ // Название кнопки
            "clr" => "primary", // цвет,
            "cmd" => ["hello", "world"] // payload
        ]
    ],
    [ // Вторая строка
        "Вторая кнопка" => [ // Название кнопки
            "clr" => "negative", // цвет,
            "cmd" => ["hello", "world2"] // payload
        ]
    ]
];
```